[*] Start mutation process:
   - targets: ch13/find_brute.py
   - tests: tests/ch13/test_find_brute.py
[*] 7 tests passed:
   - test_find_brute [0.16995 s]
[*] Start mutants generation and execution:
   - [#   1] AOD find_brute: 
--------------------------------------------------------------------------------
  27:         while (k < m and T[i + k] == P[k]):
  28:             k += 1
  29:         if k == m:
  30:             return i
- 31:     return -1
+ 31:     return 1
--------------------------------------------------------------------------------
[0.00000 s] killed by test_find_brute_basic (test_find_brute.TestFindBrute)
   - [#   2] AOR find_brute: 
--------------------------------------------------------------------------------
  21: 
  22: def find_brute(T, P):
  23:     '''Return the lowest index of T at which substring P begins (or else -1).'''
  24:     (n, m) = (len(T), len(P))
- 25:     for i in range((n - m) + 1):
+ 25:     for i in range((n + m) + 1):
  26:         k = 0
  27:         while (k < m and T[i + k] == P[k]):
  28:             k += 1
  29:         if k == m:
--------------------------------------------------------------------------------
[0.00000 s] killed by test_find_brute_basic (test_find_brute.TestFindBrute)
   - [#   3] AOR find_brute: 
--------------------------------------------------------------------------------
  21: 
  22: def find_brute(T, P):
  23:     '''Return the lowest index of T at which substring P begins (or else -1).'''
  24:     (n, m) = (len(T), len(P))
- 25:     for i in range((n - m) + 1):
+ 25:     for i in range((n - m) - 1):
  26:         k = 0
  27:         while (k < m and T[i + k] == P[k]):
  28:             k += 1
  29:         if k == m:
--------------------------------------------------------------------------------
[0.00000 s] killed by test_find_brute_basic (test_find_brute.TestFindBrute)
   - [#   4] AOR find_brute: 
--------------------------------------------------------------------------------
  23:     '''Return the lowest index of T at which substring P begins (or else -1).'''
  24:     (n, m) = (len(T), len(P))
  25:     for i in range((n - m) + 1):
  26:         k = 0
- 27:         while (k < m and T[i + k] == P[k]):
+ 27:         while (k < m and T[i - k] == P[k]):
  28:             k += 1
  29:         if k == m:
  30:             return i
  31:     return -1
--------------------------------------------------------------------------------
[0.00000 s] killed by test_find_brute_basic (test_find_brute.TestFindBrute)
   - [#   5] AOR find_brute: 
--------------------------------------------------------------------------------
  27:         while (k < m and T[i + k] == P[k]):
  28:             k += 1
  29:         if k == m:
  30:             return i
- 31:     return -1
+ 31:     return +1
--------------------------------------------------------------------------------
[0.00000 s] killed by test_find_brute_basic (test_find_brute.TestFindBrute)
   - [#   6] ASR find_brute: 
--------------------------------------------------------------------------------
  24:     (n, m) = (len(T), len(P))
  25:     for i in range((n - m) + 1):
  26:         k = 0
  27:         while (k < m and T[i + k] == P[k]):
- 28:             k += 1
+ 28:             k -= 1
  29:         if k == m:
  30:             return i
  31:     return -1
--------------------------------------------------------------------------------
[0.00000 s] killed by test_find_brute_basic (test_find_brute.TestFindBrute)
   - [#   7] COI find_brute: 
--------------------------------------------------------------------------------
  23:     '''Return the lowest index of T at which substring P begins (or else -1).'''
  24:     (n, m) = (len(T), len(P))
  25:     for i in range((n - m) + 1):
  26:         k = 0
- 27:         while (k < m and T[i + k] == P[k]):
+ 27:         while not ((k < m and T[i + k] == P[k])):
  28:             k += 1
  29:         if k == m:
  30:             return i
  31:     return -1
--------------------------------------------------------------------------------
[5.04202 s] timeout
   - [#   8] COI find_brute: 
--------------------------------------------------------------------------------
  25:     for i in range((n - m) + 1):
  26:         k = 0
  27:         while (k < m and T[i + k] == P[k]):
  28:             k += 1
- 29:         if k == m:
+ 29:         if not (k == m):
  30:             return i
  31:     return -1
--------------------------------------------------------------------------------
[0.00000 s] killed by test_find_brute_basic (test_find_brute.TestFindBrute)
   - [#   9] LCR find_brute: 
--------------------------------------------------------------------------------
  23:     '''Return the lowest index of T at which substring P begins (or else -1).'''
  24:     (n, m) = (len(T), len(P))
  25:     for i in range((n - m) + 1):
  26:         k = 0
- 27:         while (k < m and T[i + k] == P[k]):
+ 27:         while (k < m or T[i + k] == P[k]):
  28:             k += 1
  29:         if k == m:
  30:             return i
  31:     return -1
--------------------------------------------------------------------------------
[0.00000 s] killed by test_find_brute_basic (test_find_brute.TestFindBrute)
   - [#  10] ROR find_brute: 
--------------------------------------------------------------------------------
  23:     '''Return the lowest index of T at which substring P begins (or else -1).'''
  24:     (n, m) = (len(T), len(P))
  25:     for i in range((n - m) + 1):
  26:         k = 0
- 27:         while (k < m and T[i + k] == P[k]):
+ 27:         while (k > m and T[i + k] == P[k]):
  28:             k += 1
  29:         if k == m:
  30:             return i
  31:     return -1
--------------------------------------------------------------------------------
[0.00356 s] killed by test_find_brute_basic (test_find_brute.TestFindBrute)
   - [#  11] ROR find_brute: 
--------------------------------------------------------------------------------
  23:     '''Return the lowest index of T at which substring P begins (or else -1).'''
  24:     (n, m) = (len(T), len(P))
  25:     for i in range((n - m) + 1):
  26:         k = 0
- 27:         while (k < m and T[i + k] == P[k]):
+ 27:         while (k <= m and T[i + k] == P[k]):
  28:             k += 1
  29:         if k == m:
  30:             return i
  31:     return -1
--------------------------------------------------------------------------------
[0.00000 s] killed by test_find_brute_basic (test_find_brute.TestFindBrute)
   - [#  12] ROR find_brute: 
--------------------------------------------------------------------------------
  23:     '''Return the lowest index of T at which substring P begins (or else -1).'''
  24:     (n, m) = (len(T), len(P))
  25:     for i in range((n - m) + 1):
  26:         k = 0
- 27:         while (k < m and T[i + k] == P[k]):
+ 27:         while (k < m and T[i + k] != P[k]):
  28:             k += 1
  29:         if k == m:
  30:             return i
  31:     return -1
--------------------------------------------------------------------------------
[0.00000 s] killed by test_find_brute_basic (test_find_brute.TestFindBrute)
   - [#  13] ROR find_brute: 
--------------------------------------------------------------------------------
  25:     for i in range((n - m) + 1):
  26:         k = 0
  27:         while (k < m and T[i + k] == P[k]):
  28:             k += 1
- 29:         if k == m:
+ 29:         if k != m:
  30:             return i
  31:     return -1
--------------------------------------------------------------------------------
[0.00000 s] killed by test_find_brute_basic (test_find_brute.TestFindBrute)
[*] Mutation score [5.32034 s]: 100.0%
   - all: 13
   - killed: 12 (92.3%)
   - survived: 0 (0.0%)
   - incompetent: 0 (0.0%)
   - timeout: 1 (7.7%)
